{"version":3,"sources":["state.js"],"names":[],"mappings":"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","file":"state-compiled.js","sourcesContent":["import {reservedWords, keywords} from \"./identifier\"\nimport {types as tt} from \"./tokentype\"\nimport {lineBreak} from \"./whitespace\"\nimport {getOptions} from \"./options\"\n\n// Registered plugins\nexport const plugins = {}\n\nfunction keywordRegexp(words) {\n  return new RegExp(\"^(\" + words.replace(/ /g, \"|\") + \")$\")\n}\n\nexport class Parser {\n  constructor(options, input, startPos) {\n    this.options = options = getOptions(options)\n    this.sourceFile = options.sourceFile\n    this.keywords = keywordRegexp(keywords[options.ecmaVersion >= 6 ? 6 : 5])\n    let reserved = options.allowReserved ? \"\" :\n        reservedWords[options.ecmaVersion] + (options.sourceType == \"module\" ? \" await\" : \"\")\n    this.reservedWords = keywordRegexp(reserved)\n    let reservedStrict = (reserved ? reserved + \" \" : \"\") + reservedWords.strict\n    this.reservedWordsStrict = keywordRegexp(reservedStrict)\n    this.reservedWordsStrictBind = keywordRegexp(reservedStrict + \" \" + reservedWords.strictBind)\n    this.input = String(input)\n\n    // Used to signal to callers of `readWord1` whether the word\n    // contained any escape sequences. This is needed because words with\n    // escape sequences must not be interpreted as keywords.\n    this.containsEsc = false\n\n    // Load plugins\n    this.loadPlugins(options.plugins)\n\n    // Set up token state\n\n    // The current position of the tokenizer in the input.\n    if (startPos) {\n      this.pos = startPos\n      this.lineStart = Math.max(0, this.input.lastIndexOf(\"\\n\", startPos))\n      this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length\n    } else {\n      this.pos = this.lineStart = 0\n      this.curLine = 1\n    }\n\n    // Properties of the current token:\n    // Its type\n    this.type = tt.eof\n    // For tokens that include more information than their type, the value\n    this.value = null\n    // Its start and end offset\n    this.start = this.end = this.pos\n    // And, if locations are used, the {line, column} object\n    // corresponding to those offsets\n    this.startLoc = this.endLoc = this.curPosition()\n\n    // Position information for the previous token\n    this.lastTokEndLoc = this.lastTokStartLoc = null\n    this.lastTokStart = this.lastTokEnd = this.pos\n\n    // The context stack is used to superficially track syntactic\n    // context to predict whether a regular expression is allowed in a\n    // given position.\n    this.context = this.initialContext()\n    this.exprAllowed = true\n\n    // Figure out if it's a module code.\n    this.strict = this.inModule = options.sourceType === \"module\"\n\n    // Used to signify the start of a potential arrow function\n    this.potentialArrowAt = -1\n\n    // Flags to track whether we are in a function, a generator.\n    this.inFunction = this.inGenerator = false\n    // Labels in scope.\n    this.labels = []\n\n    // If enabled, skip leading hashbang line.\n    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === '#!')\n      this.skipLineComment(2)\n  }\n\n  // DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them\n  isKeyword(word) { return this.keywords.test(word) }\n  isReservedWord(word) { return this.reservedWords.test(word) }\n\n  extend(name, f) {\n    this[name] = f(this[name])\n  }\n\n  loadPlugins(pluginConfigs) {\n    for (let name in pluginConfigs) {\n      let plugin = plugins[name]\n      if (!plugin) throw new Error(\"Plugin '\" + name + \"' not found\")\n      plugin(this, pluginConfigs[name])\n    }\n  }\n\n  parse() {\n    let node = this.options.program || this.startNode()\n    this.nextToken()\n    return this.parseTopLevel(node)\n  }\n}\n"]}