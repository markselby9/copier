{"version":3,"sources":["options.js"],"names":[],"mappings":"AAAA,SAAQ,GAAR,EAAa,OAAb,QAA2B,QAA3B;AACA,SAAQ,cAAR,QAA6B,WAA7B;;;;;AAKA,OAAO,MAAM,iBAAiB;;;;;AAK5B,eAAa,CALe;;AAO5B,cAAY,QAPgB;;;;;;AAa5B,uBAAqB,IAbO;;;AAgB5B,mBAAiB,IAhBW;;;;;AAqB5B,iBAAe,IArBa;;;AAwB5B,8BAA4B,KAxBA;;;AA2B5B,+BAA6B,KA3BD;;;AA8B5B,iBAAe,KA9Ba;;;;;AAmC5B,aAAW,KAnCiB;;;;;;AAyC5B,WAAS,IAzCmB;;;;;;;;;;;AAoD5B,aAAW,IApDiB;;;;;;;;;AA6D5B,UAAQ,KA7DoB;;;;;;AAmE5B,WAAS,IAnEmB;;;AAsE5B,cAAY,IAtEgB;;;AAyE5B,oBAAkB,IAzEU;;;AA4E5B,kBAAgB,KA5EY;AA6E5B,WAAS;AA7EmB,CAAvB;;;;AAkFP,OAAO,SAAS,UAAT,CAAoB,IAApB,EAA0B;AAC/B,MAAI,UAAU,EAAd;AACA,OAAK,IAAI,GAAT,IAAgB,cAAhB,EACE,QAAQ,GAAR,IAAe,QAAQ,IAAI,IAAJ,EAAU,GAAV,CAAR,GAAyB,KAAK,GAAL,CAAzB,GAAqC,eAAe,GAAf,CAApD;AACF,MAAI,QAAQ,aAAR,IAAyB,IAA7B,EACE,QAAQ,aAAR,GAAwB,QAAQ,WAAR,GAAsB,CAA9C;;AAEF,MAAI,QAAQ,QAAQ,OAAhB,CAAJ,EAA8B;AAC5B,QAAI,SAAS,QAAQ,OAArB;AACA,YAAQ,OAAR,GAAmB,KAAD,IAAW,OAAO,IAAP,CAAY,KAAZ,CAA7B;AACD;AACD,MAAI,QAAQ,QAAQ,SAAhB,CAAJ,EACE,QAAQ,SAAR,GAAoB,YAAY,OAAZ,EAAqB,QAAQ,SAA7B,CAApB;;AAEF,SAAO,OAAP;AACD;;AAED,SAAS,WAAT,CAAqB,OAArB,EAA8B,KAA9B,EAAqC;AACnC,SAAO,UAAU,KAAV,EAAiB,IAAjB,EAAuB,KAAvB,EAA8B,GAA9B,EAAmC,QAAnC,EAA6C,MAA7C,EAAqD;AAC1D,QAAI,UAAU;AACZ,YAAM,QAAQ,OAAR,GAAkB,MADZ;AAEZ,aAAO,IAFK;AAGZ,aAAO,KAHK;AAIZ,WAAK;AAJO,KAAd;AAMA,QAAI,QAAQ,SAAZ,EACE,QAAQ,GAAR,GAAc,IAAI,cAAJ,CAAmB,IAAnB,EAAyB,QAAzB,EAAmC,MAAnC,CAAd;AACF,QAAI,QAAQ,MAAZ,EACE,QAAQ,KAAR,GAAgB,CAAC,KAAD,EAAQ,GAAR,CAAhB;AACF,UAAM,IAAN,CAAW,OAAX;AACD,GAZD;AAaD","file":"options-compiled.js","sourcesContent":["import {has, isArray} from \"./util\"\nimport {SourceLocation} from \"./locutil\"\n\n// A second optional argument can be given to further configure\n// the parser process. These options are recognized:\n\nexport const defaultOptions = {\n  // `ecmaVersion` indicates the ECMAScript version to parse. Must\n  // be either 3, or 5, or 6. This influences support for strict\n  // mode, the set of reserved words, support for getters and\n  // setters and other features. The default is 6.\n  ecmaVersion: 6,\n  // Source type (\"script\" or \"module\") for different semantics\n  sourceType: \"script\",\n  // `onInsertedSemicolon` can be a callback that will be called\n  // when a semicolon is automatically inserted. It will be passed\n  // th position of the comma as an offset, and if `locations` is\n  // enabled, it is given the location as a `{line, column}` object\n  // as second argument.\n  onInsertedSemicolon: null,\n  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for\n  // trailing commas.\n  onTrailingComma: null,\n  // By default, reserved words are only enforced if ecmaVersion >= 5.\n  // Set `allowReserved` to a boolean value to explicitly turn this on\n  // an off. When this option has the value \"never\", reserved words\n  // and keywords can also not be used as property names.\n  allowReserved: null,\n  // When enabled, a return at the top level is not considered an\n  // error.\n  allowReturnOutsideFunction: false,\n  // When enabled, import/export statements are not constrained to\n  // appearing at the top of the program.\n  allowImportExportEverywhere: false,\n  // When enabled, hashbang directive in the beginning of file\n  // is allowed and treated as a line comment.\n  allowHashBang: false,\n  // When `locations` is on, `loc` properties holding objects with\n  // `start` and `end` properties in `{line, column}` form (with\n  // line being 1-based and column 0-based) will be attached to the\n  // nodes.\n  locations: false,\n  // A function can be passed as `onToken` option, which will\n  // cause Acorn to call that function with object in the same\n  // format as tokens returned from `tokenizer().getToken()`. Note\n  // that you are not allowed to call the parser from the\n  // callback—that will corrupt its internal state.\n  onToken: null,\n  // A function can be passed as `onComment` option, which will\n  // cause Acorn to call that function with `(block, text, start,\n  // end)` parameters whenever a comment is skipped. `block` is a\n  // boolean indicating whether this is a block (`/* */`) comment,\n  // `text` is the content of the comment, and `start` and `end` are\n  // character offsets that denote the start and end of the comment.\n  // When the `locations` option is on, two more parameters are\n  // passed, the full `{line, column}` locations of the start and\n  // end of the comments. Note that you are not allowed to call the\n  // parser from the callback—that will corrupt its internal state.\n  onComment: null,\n  // Nodes have their start and end characters offsets recorded in\n  // `start` and `end` properties (directly on the node, rather than\n  // the `loc` object, which holds line/column data. To also add a\n  // [semi-standardized][range] `range` property holding a `[start,\n  // end]` array with the same numbers, set the `ranges` option to\n  // `true`.\n  //\n  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n  ranges: false,\n  // It is possible to parse multiple files into a single AST by\n  // passing the tree produced by parsing the first file as\n  // `program` option in subsequent parses. This will add the\n  // toplevel forms of the parsed file to the `Program` (top) node\n  // of an existing parse tree.\n  program: null,\n  // When `locations` is on, you can pass this to record the source\n  // file in every node's `loc` object.\n  sourceFile: null,\n  // This value, if given, is stored in every node, whether\n  // `locations` is on or off.\n  directSourceFile: null,\n  // When enabled, parenthesized expressions are represented by\n  // (non-standard) ParenthesizedExpression nodes\n  preserveParens: false,\n  plugins: {}\n}\n\n// Interpret and default an options object\n\nexport function getOptions(opts) {\n  let options = {}\n  for (let opt in defaultOptions)\n    options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]\n  if (options.allowReserved == null)\n    options.allowReserved = options.ecmaVersion < 5\n\n  if (isArray(options.onToken)) {\n    let tokens = options.onToken\n    options.onToken = (token) => tokens.push(token)\n  }\n  if (isArray(options.onComment))\n    options.onComment = pushComment(options, options.onComment)\n\n  return options\n}\n\nfunction pushComment(options, array) {\n  return function (block, text, start, end, startLoc, endLoc) {\n    let comment = {\n      type: block ? 'Block' : 'Line',\n      value: text,\n      start: start,\n      end: end\n    }\n    if (options.locations)\n      comment.loc = new SourceLocation(this, startLoc, endLoc)\n    if (options.ranges)\n      comment.range = [start, end]\n    array.push(comment)\n  }\n}\n\n"]}