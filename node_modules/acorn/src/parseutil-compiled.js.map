{"version":3,"sources":["parseutil.js"],"names":[],"mappings":"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","file":"parseutil-compiled.js","sourcesContent":["import {types as tt} from \"./tokentype\"\nimport {Parser} from \"./state\"\nimport {lineBreak} from \"./whitespace\"\n\nconst pp = Parser.prototype\n\n// ## Parser utilities\n\n// Test whether a statement node is the string literal `\"use strict\"`.\n\npp.isUseStrict = function(stmt) {\n  return this.options.ecmaVersion >= 5 && stmt.type === \"ExpressionStatement\" &&\n    stmt.expression.type === \"Literal\" &&\n    stmt.expression.raw.slice(1, -1) === \"use strict\"\n}\n\n// Predicate that tests whether the next token is of the given\n// type, and if yes, consumes it as a side effect.\n\npp.eat = function(type) {\n  if (this.type === type) {\n    this.next()\n    return true\n  } else {\n    return false\n  }\n}\n\n// Tests whether parsed token is a contextual keyword.\n\npp.isContextual = function(name) {\n  return this.type === tt.name && this.value === name\n}\n\n// Consumes contextual keyword if possible.\n\npp.eatContextual = function(name) {\n  return this.value === name && this.eat(tt.name)\n}\n\n// Asserts that following token is given contextual keyword.\n\npp.expectContextual = function(name) {\n  if (!this.eatContextual(name)) this.unexpected()\n}\n\n// Test whether a semicolon can be inserted at the current position.\n\npp.canInsertSemicolon = function() {\n  return this.type === tt.eof ||\n    this.type === tt.braceR ||\n    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n}\n\npp.insertSemicolon = function() {\n  if (this.canInsertSemicolon()) {\n    if (this.options.onInsertedSemicolon)\n      this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc)\n    return true\n  }\n}\n\n// Consume a semicolon, or, failing that, see if we are allowed to\n// pretend that there is a semicolon at this position.\n\npp.semicolon = function() {\n  if (!this.eat(tt.semi) && !this.insertSemicolon()) this.unexpected()\n}\n\npp.afterTrailingComma = function(tokType) {\n  if (this.type == tokType) {\n    if (this.options.onTrailingComma)\n      this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc)\n    this.next()\n    return true\n  }\n}\n\n// Expect a token of a given type. If found, consume it, otherwise,\n// raise an unexpected token error.\n\npp.expect = function(type) {\n  this.eat(type) || this.unexpected()\n}\n\n// Raise an unexpected token error.\n\npp.unexpected = function(pos) {\n  this.raise(pos != null ? pos : this.start, \"Unexpected token\")\n}\n\npp.checkPatternErrors = function(refDestructuringErrors, andThrow) {\n  let pos = refDestructuringErrors && refDestructuringErrors.trailingComma\n  if (!andThrow) return !!pos\n  if (pos) this.raise(pos, \"Comma is not permitted after the rest element\")\n}\n\npp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {\n  let pos = refDestructuringErrors && refDestructuringErrors.shorthandAssign\n  if (!andThrow) return !!pos\n  if (pos) this.raise(pos, \"Shorthand property assignments are valid only in destructuring patterns\")\n}\n"]}